%% Final Project Main File
% 
% Steps: 
%     1. Dialog for user to choose which mode we are in (IK, RR, JT)
%     2. Move UR5 manually to the end position
%     3. Press button to log end position kinematics
%     4. Move UR5 manually to the start position
%     5. Press button to log start postition kinematics
%     6. Generate a trajectory depending on which mode we are in (IK, RR, JT)
%     7. Loop to traverse from start to end position

%%
disp('Setting up UR5 and necessary frames ...');
ur5 = ur5_interface();
ur5.move_joints(ur5.home(), 5);
pause(6);

g_baseK_S = [ROTZ(-pi/2) [0 0 0.0892]'; 0 0 0 1];  %transformation from keating base to {S}
g_T_toolK = [ROTX(-pi/2)*ROTY(pi/2) [0 0 0]'; 0 0 0 1]; % tool k is inline with tool 0
g_baselink_baseK = [ROTZ(pi), [0; 0; 0]; 0, 0, 0, 1];
tf_frame('base_link', 'baseK', g_baselink_baseK);
pause(0.5);
tf_frame('baseK', 'S', g_baseK_S);
pause(0.5);
tf_frame('tool0', 'T', inv(g_T_toolK));
pause(0.5);

while (1)
    mode = input("Enter a control mode: 0 - Inverse Kinematics, 1 - Resolved Rate, 2 - Transpose Jacobian\n");
    try 
        if (0 <= mode && mode <= 2)
            break
        else
            disp("Please enter 0, 1, or 2.");
        end
    catch
        disp("Please enter a valid integer.");
    end
end

input("Move UR5 to ending position and press enter.");
gend = ur5.get_current_transformation('S', 'T');
input("Move UR5 to starting position and press enter.");
gstart = ur5.get_current_transformation('S', 'T');
%%
if mode == 0 || mode == 1
    g1 = gstart;
    p = gend(1:2, 4) - gstart(1:2, 4);
    [~, idx1] = max(abs(p));
    [~, idx2] = min(abs(p));
    g1(idx1, 4) = g1(idx1, 4) + 2/3*(gend(idx1, 4) - gstart(idx1, 4));
    g2 = g1;
    g2(idx2, 4) = g2(idx2, 4) + (gend(idx2, 4) - gstart(idx2, 4));
    gend = [g2(1:3, 1:3), [gend(1:2, 4); g2(3, 4)]; 0 0 0 1];
    
    tf_frame('S', 'gstart', gstart);
    pause(0.5);
    tf_frame('S', 'g1', g1);
    pause(0.5);
    tf_frame('S', 'g2', g2);
    pause(0.5);
    tf_frame('S', 'gend', gend);
    pause(0.5);

    v = 0.05;
    drawLine(gstart, g1, mode, v, ur5, theta1(:, 1));
    drawLine(g1, g1, mode, v, ur5, theta1(:, 1));
    drawLine(gstart, g1, mode, v, ur5, theta1(:, 1));
else
    

%%


%%
% ur5 = ur5_interface();
% ur5.move_joints(ur5.home(), 10);
% pause(11);
% g1 = [eye(3), [0.5; 0.2; 0]; zeros(1, 3), 1];
% g1 = ur5.get_current_transformation("baseK", "tool0");
theta1 = ur5InvKin(g1);
% g1approx = ur5FwdKin(theta1(:, 1))
ur5.move_joints(theta1(:, 1), 5);
pause(6);
% theta1(:, 1);
% qnow = ur5.get_current_joints();
% gnow = ur5.get_current_transformation("S", "T")
% g1-gnow
% qnow-theta(:, 1)
v = 0.01; % m/s
drawLine(g1, g2, 0, v, ur5, theta1(:, 1));
%%
q = ur5.get_current_joints()
gnow = ur5FwdKin(q);
q_approx = ur5InvKin(gnow)
%%
% theta1 = ur5InvKin(g1);
ur5.move_joints(theta1(:, 1), 5);
pause(6);
v = 0.05; % m/s
drawLine(g1, g2, 0, v, ur5, theta1(:, 1));
